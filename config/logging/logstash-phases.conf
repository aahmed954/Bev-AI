# Logstash Configuration for Phase 7-9 Services
# Processing and parsing logs from new BEV OSINT services

input {
  beats {
    port => 5044
    type => "filebeat"
  }
}

filter {
  # =============================================================================
  # COMMON PROCESSING FOR ALL PHASES
  # =============================================================================

  # Parse timestamp
  date {
    match => [ "@timestamp", "ISO8601" ]
  }

  # Add phase information for routing and indexing
  if [phase] == "7" {
    mutate {
      add_field => { "phase_name" => "alternative-market-intelligence" }
      add_field => { "index_pattern" => "bev-phase7" }
    }
  } else if [phase] == "8" {
    mutate {
      add_field => { "phase_name" => "advanced-security-operations" }
      add_field => { "index_pattern" => "bev-phase8" }
    }
  } else if [phase] == "9" {
    mutate {
      add_field => { "phase_name" => "autonomous-enhancement" }
      add_field => { "index_pattern" => "bev-phase9" }
    }
  }

  # =============================================================================
  # PHASE 7 - MARKET INTELLIGENCE SPECIFIC PROCESSING
  # =============================================================================

  if [phase] == "7" {
    if [service] == "dm-crawler" {
      # Parse DM crawler logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract crawling metrics
      if [log_message] =~ /crawled|scraped/ {
        grok {
          match => {
            "log_message" => ".*crawled (?<pages_crawled>\d+) pages.*"
          }
          tag_on_failure => ["_grokparsefailure_dm_crawler_pages"]
        }
        if [pages_crawled] {
          mutate {
            convert => { "pages_crawled" => "integer" }
            add_field => { "metric_type" => "crawling_performance" }
          }
        }
      }

      # Extract rate limiting events
      if [log_message] =~ /rate limit|throttled/ {
        mutate {
          add_field => { "event_type" => "rate_limit" }
          add_field => { "alert_level" => "warning" }
        }
      }
    }

    if [service] == "crypto-intel" {
      # Parse crypto intelligence logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract blockchain analysis metrics
      if [log_message] =~ /blockchain|transaction/ {
        grok {
          match => {
            "log_message" => ".*analyzed (?<transactions_analyzed>\d+) transactions.*"
          }
          tag_on_failure => ["_grokparsefailure_crypto_intel_transactions"]
        }
        if [transactions_analyzed] {
          mutate {
            convert => { "transactions_analyzed" => "integer" }
            add_field => { "metric_type" => "analysis_performance" }
          }
        }
      }

      # Extract suspicious activity alerts
      if [log_message] =~ /suspicious|alert|flagged/ {
        mutate {
          add_field => { "event_type" => "security_alert" }
          add_field => { "alert_level" => "high" }
        }
      }
    }

    if [service] == "reputation-analyzer" {
      # Parse reputation analysis logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract model performance metrics
      if [log_message] =~ /accuracy|precision|recall/ {
        grok {
          match => {
            "log_message" => ".*accuracy: (?<model_accuracy>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_reputation_accuracy"]
        }
        if [model_accuracy] {
          mutate {
            convert => { "model_accuracy" => "float" }
            add_field => { "metric_type" => "model_performance" }
          }
        }
      }
    }

    if [service] == "economics-processor" {
      # Parse economics processing logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract prediction metrics
      if [log_message] =~ /prediction|forecast/ {
        grok {
          match => {
            "log_message" => ".*prediction accuracy: (?<prediction_accuracy>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_economics_prediction"]
        }
        if [prediction_accuracy] {
          mutate {
            convert => { "prediction_accuracy" => "float" }
            add_field => { "metric_type" => "prediction_performance" }
          }
        }
      }
    }
  }

  # =============================================================================
  # PHASE 8 - SECURITY OPERATIONS SPECIFIC PROCESSING
  # =============================================================================

  if [phase] == "8" {
    if [service] == "tactical-intel" {
      # Parse tactical intelligence logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract threat detection events
      if [log_message] =~ /threat|attack|malicious/ {
        mutate {
          add_field => { "event_type" => "threat_detection" }
          add_field => { "alert_level" => "critical" }
        }

        grok {
          match => {
            "log_message" => ".*threat score: (?<threat_score>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_threat_score"]
        }
        if [threat_score] {
          mutate {
            convert => { "threat_score" => "float" }
          }
        }
      }
    }

    if [service] == "defense-automation" {
      # Parse defense automation logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract automated response events
      if [log_message] =~ /response|mitigation|blocked/ {
        mutate {
          add_field => { "event_type" => "automated_response" }
        }

        grok {
          match => {
            "log_message" => ".*response time: (?<response_time>\d+)ms.*"
          }
          tag_on_failure => ["_grokparsefailure_response_time"]
        }
        if [response_time] {
          mutate {
            convert => { "response_time" => "integer" }
            add_field => { "metric_type" => "response_performance" }
          }
        }
      }
    }

    if [service] == "opsec-enforcer" {
      # Parse OPSEC enforcement logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract policy violations
      if [log_message] =~ /violation|breach|policy/ {
        mutate {
          add_field => { "event_type" => "policy_violation" }
          add_field => { "alert_level" => "high" }
        }
      }

      # Extract anonymity metrics
      if [log_message] =~ /anonymity|privacy/ {
        grok {
          match => {
            "log_message" => ".*anonymity score: (?<anonymity_score>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_anonymity_score"]
        }
        if [anonymity_score] {
          mutate {
            convert => { "anonymity_score" => "float" }
            add_field => { "metric_type" => "privacy_performance" }
          }
        }
      }
    }

    if [service] == "intel-fusion" {
      # Parse intelligence fusion logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract correlation events
      if [log_message] =~ /correlation|fusion|pattern/ {
        mutate {
          add_field => { "event_type" => "intelligence_correlation" }
        }

        grok {
          match => {
            "log_message" => ".*confidence: (?<correlation_confidence>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_correlation_confidence"]
        }
        if [correlation_confidence] {
          mutate {
            convert => { "correlation_confidence" => "float" }
            add_field => { "metric_type" => "correlation_performance" }
          }
        }
      }
    }
  }

  # =============================================================================
  # PHASE 9 - AUTONOMOUS SYSTEMS SPECIFIC PROCESSING
  # =============================================================================

  if [phase] == "9" {
    if [service] == "autonomous-coordinator" {
      # Parse autonomous coordination logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract autonomous decisions
      if [log_message] =~ /decision|autonomous|coordination/ {
        mutate {
          add_field => { "event_type" => "autonomous_decision" }
        }

        grok {
          match => {
            "log_message" => ".*decision accuracy: (?<decision_accuracy>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_decision_accuracy"]
        }
        if [decision_accuracy] {
          mutate {
            convert => { "decision_accuracy" => "float" }
            add_field => { "metric_type" => "autonomy_performance" }
          }
        }
      }
    }

    if [service] == "adaptive-learning" {
      # Parse adaptive learning logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract learning metrics
      if [log_message] =~ /training|learning|model/ {
        grok {
          match => {
            "log_message" => ".*model performance: (?<model_performance>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_model_performance"]
        }
        if [model_performance] {
          mutate {
            convert => { "model_performance" => "float" }
            add_field => { "metric_type" => "learning_performance" }
          }
        }
      }
    }

    if [service] == "resource-manager" {
      # Parse resource management logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract resource optimization metrics
      if [log_message] =~ /optimization|scaling|resource/ {
        grok {
          match => {
            "log_message" => ".*optimization efficiency: (?<optimization_efficiency>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_optimization_efficiency"]
        }
        if [optimization_efficiency] {
          mutate {
            convert => { "optimization_efficiency" => "float" }
            add_field => { "metric_type" => "resource_performance" }
          }
        }
      }
    }

    if [service] == "knowledge-evolution" {
      # Parse knowledge evolution logs
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}"
        }
      }

      # Extract knowledge graph metrics
      if [log_message] =~ /knowledge|semantic|evolution/ {
        grok {
          match => {
            "log_message" => ".*semantic drift: (?<semantic_drift>\d+\.\d+).*"
          }
          tag_on_failure => ["_grokparsefailure_semantic_drift"]
        }
        if [semantic_drift] {
          mutate {
            convert => { "semantic_drift" => "float" }
            add_field => { "metric_type" => "knowledge_performance" }
          }
        }
      }
    }
  }

  # =============================================================================
  # SECURITY AND COMPLIANCE PROCESSING
  # =============================================================================

  # Additional PII redaction (belt and suspenders approach)
  mutate {
    gsub => [
      "message", "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b", "[EMAIL_REDACTED]",
      "message", "\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b", "[IP_REDACTED]",
      "log_message", "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b", "[EMAIL_REDACTED]",
      "log_message", "\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b", "[IP_REDACTED]"
    ]
  }

  # Tag high-priority events for alerting
  if [alert_level] == "critical" or [event_type] == "threat_detection" {
    mutate {
      add_tag => [ "alert", "high_priority" ]
    }
  }

  # Add enrichment fields
  mutate {
    add_field => { "log_source" => "bev-osint" }
    add_field => { "processing_timestamp" => "%{@timestamp}" }
  }

  # Remove temporary fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "input", "fields" ]
  }
}

output {
  # Route logs to appropriate Elasticsearch indices
  if [phase] == "7" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}"]
      index => "bev-phase7-logs-%{+YYYY.MM.dd}"
      template_name => "bev-phase7"
      template_pattern => "bev-phase7-*"
      template => "/usr/share/logstash/templates/bev-phase7-template.json"
    }
  } else if [phase] == "8" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}"]
      index => "bev-phase8-logs-%{+YYYY.MM.dd}"
      template_name => "bev-phase8"
      template_pattern => "bev-phase8-*"
      template => "/usr/share/logstash/templates/bev-phase8-template.json"
    }
  } else if [phase] == "9" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}"]
      index => "bev-phase9-logs-%{+YYYY.MM.dd}"
      template_name => "bev-phase9"
      template_pattern => "bev-phase9-*"
      template => "/usr/share/logstash/templates/bev-phase9-template.json"
    }
  } else {
    # Default fallback
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}"]
      index => "bev-unified-logs-%{+YYYY.MM.dd}"
    }
  }

  # Output high-priority alerts to separate index for rapid alerting
  if "high_priority" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}"]
      index => "bev-alerts-%{+YYYY.MM.dd}"
    }
  }

  # Debug output for development (comment out in production)
  # stdout { codec => rubydebug }
}